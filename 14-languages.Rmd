# Other Languages {#other-languages}

Besides the R language, many other languages are supported in R Markdown through the **knitr** package. The language name is indicated by the first word in the curly braces after the three opening backticks. For example, the little `r` in ```` ```{r}```` indicates that the code chunk contains R code, and ```` ```{python}```` is a Python code chunk.

In **knitr**, each language is supported through a language engine. Language engines are essentially functions that takes the source code and options of a chunk as the input, and returns a character string as the output. They are managed through the object `knitr::knit_engines`. You may check the existing engines via:

```{r}
names(knitr::knit_engines$get())
```

[Section 2.7](https://bookdown.org/yihui/rmarkdown/language-engines.html) of the R Markdown Definitive Guide [@rmarkdown2018] has shown examples of using Python, Shell, SQL, Rcpp, Stan, JavaScript, CSS, Julia, C, and Fortran code in R Markdown. In this chapter, we will show more language engines. First, let's reveal how a language engine works by registering a custom language engine.

## Register a custom language engine {#custom-engine}

You can register a custom language engine via the `knitr::knit_engines$set()` method, which accepts a function as its input, e.g.,

```{r, eval=FALSE}
knitr::knit_engines$set(foo = function(options) {
  # the source code is in options$code;
  # just do whatever you want with it
})
```

This registers the `foo` engine, and you will be able to use a code chunk that starts with ```` ```{foo}````.

The engine function has one argument `options`, which is a list of chunk options of the code chunk, among which you can access the source code of the chunk as a character vector in `options$code`. For example, for the code chunk:

````md
```{foo}`r ''`
1 + 1
2 + 2
```
````

The `code` element of `options` would be a character vector `c('1 + 1', '2 + 2')`.

Language engines do not really have to deal with computer languages, but can process any text in a code chunk. First, we show a simple example of an engine that converts the content of a code chunk to uppercase:

```{r}
knitr::knit_engines$set(upper = function(options) {
  code <- paste(options$code, collapse = '\n')
  if (options$eval) toupper(code) else code
})
```

The key is that we apply the function `toupper` to the "code", and return the result as a single character string (by concatenating all lines of code by `\n`). Note that `toupper()` is applied only when the chunk option `eval = TRUE`, otherwise the original string is returned. This shows you how to make use of chunk options like `eval` inside the engine function. Similarly, you may consider adding `if (options$results == 'hide') return()` to the function body to hide the output when the chunk option `results = 'hide'`. Below is an example chunk that uses the `upper` engine, with its output:

::: {.infobox .tip data-latex="{tip}"}
````md
```{upper}`r ''`
Hello, **knitr** engines!
```
````

```{upper}
Hello, **knitr** engines!
```
:::

Next we show an example of an alternative Python engine named `py` and implemented by simply calling the `python` command via `system2()`:

```{r}
knitr::knit_engines$set(py = function(options) {
  code <- paste(options$code, collapse = '\n')
  out  <- system2(
    'python', c('-c', shQuote(code)), stdout = TRUE
  )
  knitr::engine_output(options, code, out)
})
```

To fully understand the above engine function, you need to know that:

1. Given Python code as a character string (`code` in the above function), we can execute the code via a command-line call `python -c 'code'`. That is what `system2()` does. We collect the (text) output by specifying `stdout = TRUE` in `system2()`.

1. You can pass the chunk options, source code, and text output to the function `knitr::engine_output()` to generate the final output. This function deals with common chunk options like `echo = FALSE` and `results = 'hide'`, so you do not need to take care of these cases.

A lot of language engines in **knitr** are defined in this way (i.e., using `system2()` to execute commands corresponding to languages). If you are curious about the technical details, you may check out the source code of most language engines in the R source code here: https://github.com/yihui/knitr/blob/master/R/engine.R.

Now we can use the new engine `py`, e.g.,

::: {.infobox .tip data-latex="{tip}"}
````md
```{py}`r ''`
print(1 + 1)
```
````

```{py, echo=FALSE}
print(1 + 1)
```
:::

You can even override existing language engines via `knitr::knit_engines$set()`, if you are sure that your versions are necessary or better than the existing ones. Usually we do not recommend that you do this because it may surprise users who are familiar with existing engines, but we want to make you aware of this possibility anyway.

## Conditional content via the `asis` engine {#eng-asis}

As its name indicates, the `asis` engine writes out the chunk content as is. The advantage of using this engine is that you can include some content conditionally---the display of the chunk content is decided by the chunk option `echo`. When `echo = FALSE`, the chunk will be hidden. Below is a simple example:

````md
```{r}`r ''`
getRandomNumber <- function() {
  sample(1:6, 1)
}
```

```{asis, echo = getRandomNumber() == 4}`r ''`
According to https://xkcd.com/221/, we just generated
a **true** random number!
```
````

The text in the `asis` chunk will be displayed only if the condition `getRandomNumber() == 4` is (randomly) true.

## Execute Shell scripts {#eng-bash}

You can run Shell scripts via the `bash` or `sh` or `zsh` engine, depending on which shell you prefer. Below is a `bash` example, with the chunk header ```` ```{bash}````:

```{bash}
ls *.Rmd | head -n 5
```

Please note that `bash` is invoked with the R function `system2()`, and it will ignore profile files like `~/.bash_profile` and `~/.bash_login`, in which you may have defined command aliases or modified environment variables like the `PATH` variable. If you want these profile files to be executed just like when you use the terminal, you may pass the argument `-l` to `bash` via `engine.opts`, e.g.,

````md
```{bash, engine.opts='-l'}`r ''`
echo $PATH
```
````

If you want to enable the `-l` argument globally for all `bash` chunks, you may set it in the global chunk option in the beginning of your document:

```{r, eval=FALSE}
knitr::opts_chunk$set(engine.opts = list(bash = '-l'))
```

You can also pass other arguments to `bash` by providing them as a character vector to the chunk option `engine.opts`.

## Write the chunk content to a file via the `cat` engine {#eng-cat}

Sometimes it could be useful to write the content of a code chunk to an external file, and use this file later in other code chunks. Of course, you may do this via the R functions like `writeLines()`, but the problem is that when the content is relatively long, or contains special characters, the character string that you would pass to `writeLines()` may look awkward. Below is an example of writing a long character string to a file `my-file.txt`:

```{r, eval=FALSE}
writeLines("This is a long character string.
It has multiple lines. Remember to escape
double quotes \"\", but 'single quotes' are OK.
I hope you not to lose your sanity when thinking
about how many backslashes you need, e.g., is it
'\t' or '\\t' or '\\\\t'?",
con = "my-file.txt")
```

The `cat` engine in **knitr** has provided a way for you to present text content in a code chunk and/or write it to an external file, without thinking about all the rules about R's character strings (e.g., you need double backslashes when you need a literal backslash).

To write the chunk content to a file, specify the file path in the chunk option `engine.opts`, e.g., `engine.opts = list(file = 'path/to/file')`. Under the hood, the list of values specified in `engine.opts` will be passed to the function `base::cat()`, and `file` is one of the arguments of `base::cat()`.

Next we will present three examples to illustrate the use of the `cat` engine.

### Write to a CSS file

As shown in Section \@ref(chunk-styling), you can embed a `css` code chunk in an Rmd document to style elements with CSS. An alternative way is to provide a custom CSS file to Pandoc via the `css` option of some R Markdown output formats such as `html_document`. The `cat` engine can be used to write this CSS file from Rmd.

This example below shows how to generate a file `custom.css` from a chunk in the
document, and pass the file path to the `css` option of the `html_document` format:

`r import_example("cat-css.Rmd")`

The only difference between the `css` code chunk approach and this approach is that the former approach writes the CSS code in place (i.e., in the place of the code chunk), which is inside the `<body>` tag of the output document, and the latter approach writes CSS to the `<head>` area of the output document. There will not be any practical visual differences in the output document.

### Include LaTeX code in the preamble

In Section \@ref(latex-preamble), we introduced how to add LaTeX code to the preamble, which requires an external `.tex` file. This file can also be generated from Rmd, and here is an example:

`r import_example("cat-latex.Rmd")`

In the LaTeX code in the `cat` code chunk above, we have defined the header and footer of the PDF document. If we also want to show the author name in the footer, we can append the author information to `preamble.tex` in another `cat` code chunk with options `engine.opts = list(file = 'preamble.tex', append = TRUE)` and `code = sprintf('\\fancyfoot[LO,RE]{%s}', rmarkdown::metadata$author)`. To understand how this works, recall that we mentioned earlier in this section that `engine.opts` is passed to `base::cat()` (so `append = TRUE` is passed to `cat()`), and you may understand the chunk option `code` by reading Section \@ref(option-code).

### Write YAML data to a file and also display it

By default, the content of the `cat` code chunk will not be displayed in the output document. If you also want to display it after writing it out, set the chunk option `class.source` to a language name. The language name is used for syntax highlighting. In the example below, we specify the language to be `yaml`:

````md
```{cat, engine.opts=list(file='demo.yml'), class.source='yaml'}`r ''`
a:
  aa: "something"
  bb: 1
b:
  aa: "something else"
  bb: 2
```
````

Its output is displayed below, and it also generated a file `demo.yml`.

```{cat, engine.opts=list(file='demo.yml'), class.source='yaml'}
a:
  aa: "something"
  bb: 1
b:
  aa: "something else"
  bb: 2
```

To show the file `demo.yml` is really generated, we can try to read it into R with the **yaml** package:

```{r}
str(yaml::read_yaml('demo.yml'))
```

```{r, include=FALSE}
unlink('demo.yml')
```
