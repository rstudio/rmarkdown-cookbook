# Document Elements

In this chapter, we introduce some tips and tricks that can be used to customize the content of R Markdown documents.

## Bibliographies and citations {#bibliography}

<!-- https://stackoverflow.com/questions/32946203/including-bibliography-in-rmarkdown-document-with-use-of-the-knitcitations -->

For an overview of including bibliographies in your output document, you may see [Section 2.8](https://bookdown.org/yihui/bookdown/citations.html) of @xie2016bookdown. The basic usage requires us to specify a bibliography file using the `bibliography` metadata field in YAML. For example:

```yaml
---
output: html_document
bibliography: references.bib  
---
```

where the BibTeX database is a plain-text file with the `*.bib` extension that consists of bibliography entries like this:

```bibtex
@Manual{R-base,
  title = {R: A Language and Environment for Statistical
           Computing},
  author = {{R Core Team}},
  organization = {R Foundation for Statistical Computing},
  address = {Vienna, Austria},
  year = {2019},
  url = {https://www.R-project.org},
}
```

Items can be cited directly within the documentation using the syntax `@key` where `key` is the citation key in the first line of the entry, e.g., `@R-base`. To put citations in parentheses, use `[@key]`. To cite multiple entries, separate the keys by semicolons, e.g., `[@key-1; @key-2; @key-3]`.

### Changing citation style

By default, Pandoc will use a Chicago author-date format for citations and references. To use another style, you will need to specify a CSL (Citation Style Language) style file in the `csl` metadata field, e.g.,

```yaml
---
output: html_document
bibliography: references.bib
csl: biomed-central.csl
---
```

To find your required formats, we recommend using [the Zotero website](https://www.zotero.org/styles), which makes it easy to search for and download your desired style.

CSL files can be tweaked to meet custom formatting requirements. For example, we can change the number of authors required before "et. al" is used to abbreviate them. This can be simplified through the use of visual editors such as the one available at http://editor.citationstyles.org.

### Add an item to bibliography without using it 

By default, the bibliography will only display items that are directly referenced in the document. If you want to include items in the bibliography without actually citing them in the body text, you can define a dummy `nocite` metadata field and put the citations there.

```yaml
---
nocite: |
  @item1, @item2
---
```


### Add all items to bibliography

If we do not wish to explicitly state all of the items within the bibliography but would still like to show them in our references, we can use the following syntax:

```yaml
---
nocite: '@*'
---
```

This will force all items to be displayed in the bibliography.

### Include appendix after bibliography

<!-- https://stackoverflow.com/questions/41532707/include-rmd-appendix-after-references/42258998#42258998 -->
<!-- https://stackoverflow.com/questions/16427637/pandoc-insert-appendix-after-bibliography?noredirect=1&lq=1 -->

By default, the bibliography appears at the very end of the document. However, there can be cases in which we want to place additional text after the references, most typically if we wish to include appendices in the document. We can force the position of the references by using `<div id="refs"></div>`, as shown below:

```md
# References

<div id="refs"></div>

# Appendix
```

We can improve this further by using the **bookdown** package, which offers a [special header](https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html#special-headers) for the appendix as shown with the syntax below:

```md
# References

<div id="refs"></div>

# (APPENDIX) Appendix {-} 

# Appendix A

# Appendix B
```

The numbering style of appendices will be automatically changed in LaTeX/PDF and HTML output (usually in the form A, A.1, A.2, B, B.1, and so on).

## Cross-referencing within documents {#cross-ref}

<!--https://stackoverflow.com/questions/38861041/knitr-rmarkdown-latex-how-to-cross-reference-figures-and-tables-->

Cross-referencing is a useful way of directing your readers through your document, and can be automatically done within R Markdown. While this has been explained in [Chapter 2](https://bookdown.org/yihui/bookdown/components.html) from the **bookdown** book, we want to present a brief summary below.

To use cross-references, you have to:

- **Use a bookdown output format**: cross-referencing is not provided directly within the base **rmarkdown** package, but is provided as an extension in **bookdown**. We must therefore use an output format from **bookdown** (e.g., `html_document2`, `pdf_document2`, and `word_document2`, etc.) in the YAML `output` field.

- **A caption to your figure (or table)**: figures without a caption will be included directly as images and will therefore not be a numbered figure.

- **A labeled code chunk**: this provides the identifier for referencing the figure generated by the chunk.

After these conditions are met, we can make cross-references within the text using the syntax `\@ref(type:label)`, where `label` is the chunk label and `type` is the environment being referenced (e.g. `tab`, `fig`, or `eqn`). An example is provided below:

`r import_example('cross-ref.Rmd')`

The output of this document is shown in Figure \@ref(fig:bookdown-ref). 

```{r bookdown-ref, fig.cap="Example of cross-referencing within an R Markdown document.", fig.align='center', echo=FALSE}
knitr::include_graphics("images/bookdown-ref.png", dpi = NA)
```

You can also cross-reference equations, theorems, and section headers. These types of references are explained further in Section 2.2 and Section 2.6 of the **bookdown** book.

## Update the date automatically {#update-date}

<!-- https://stackoverflow.com/questions/23449319/yaml-current-date-in-rmarkdown -->

If you want the date on which the Rmd document is compiled to be reflected in the output report, you can add an inline R expression to the `date` field in YAML, and use the `Sys.Date()` or `Sys.time()` function to obtain the current date, e.g.,

```yaml
date: "`r knitr::inline_expr('Sys.Date()')`"
```

You may want to specify the desired date or date-time format to make it more human-readable, e.g.,

```yaml
date: "`r knitr::inline_expr("format(Sys.time(), '%d %B, %Y')")`"
```

This will generate the date dynamically each time you knit your document, e.g., `r format(Sys.time(), '%d %B, %Y')`. If you wish to customize the format of the dates, you can alter the time format by providing your own format string. Here are some examples:

- `%B %Y`: `r format(Sys.time(), '%B %Y')`
- `%d/%m/%y`: `r format(Sys.time(), '%d/%m/%y')`
- `%a/%d/%b`: `r format(Sys.time(), '%a %d %b')`

A full table of POSIXct formats is shown in Table \@ref(tab:date-format).

Table: (\#tab:date-format) Date and time formats in R.

|Code |Meaning                       |Code |Meaning                                       |
|:----|:-----------------------------|:----|:---------------------------------------------|
|%a   |Abbreviated weekday           |%A   |Full weekday                                  |
|%b   |Abbreviated month             |%B   |Full month                                    |
|%c   |Locale-specific date and time |%d   |Decimal date                                  |
|%H   |Decimal hours (24 hour)       |%I   |Decimal hours (12 hour)                       |
|%j   |Decimal day of the year       |%m   |Decimal month                                 |
|%M   |Decimal minute                |%p   |Locale-specific AM/PM                         |
|%S   |Decimal second                |%U   |Decimal week of the year (starting on Sunday) |
|%w   |Decimal Weekday (0=Sunday)    |%W   |Decimal week of the year (starting on Monday) |
|%x   |Locale-specific Date          |%X   |Locale-specific Time                          |
|%y   |2-digit year                  |%Y   |4-digit year                                  |
|%z   |Offset from GMT               |%Z   |Time zone (character)                         |

As a final note, you may also want to include some explanatory text along with the date. You can add any text such as "Last compiled on" before the R code as follows:

```yaml
date: "Last compiled on `r knitr::inline_expr("format(Sys.time(), '%d %B, %Y')")`"
```

## Multiple authors in a document {#multiple-authors}

<!-- https://stackoverflow.com/questions/26043807/multiple-authors-and-subtitles-in-rmarkdown-yaml -->

We can add multiple authors to an R Markdown document within the YAML frontmatter in a number of ways. If we simply want to list them on the same line, we can provide a single string to the document, e.g.,

```yaml
---
title: "Untitled"
author: "John Doe, Jane Doe"
---
```

Alternatively, if we wish for each entry to be on its own line, we can provide a list of entries to the YAML field. This can be useful if you wish to include further information about each author such as an Email address or institution, e.g.,

```yaml
---
author:
  - John Doe, Institution One
  - Jane Doe, Institution Two
---
```

We can make use of the Markdown syntax `^[]` to add additional information as a footnote to the document. This may be more useful if you have extended information that you wish to include for each author, such as providing a contact Email and address. The exact behavior will depend on the output format:

```yaml
---
author:
  - John Doe^[Institution One, john@example.org]
  - Jane Doe^[Institution Two, jane@example.org]
---
```

Certain R Markdown templates will allow you to specify additional parameters directly within the YAML. For example, the [Distill](https://rstudio.github.io/distill/) output format allows `url`, `affiliation`, and `affiliation_url` to be specified. After you install the **distill** package:

```{r, eval=FALSE}
install.packages('distill')
```

You can use the Distill format with detailed author information, e.g.,

```yaml
---
title: "Distill for R Markdown"
author:
  - name: "JJ Allaire"
    url: https://github.com/jjallaire
    affiliation: RStudio
    affiliation_url: https://www.rstudio.com
output: distill::distill_article
---
```

## Numbered figure captions {#figure-number}

<!-- https://stackoverflow.com/questions/37116632/r-markdown-html-number-figures -->

We can use **bookdown** output formats to add figure numbers to their captions. Below is an example:

```yaml
---
output: bookdown::html_document2
---
```

````md
```{r cars, fig.cap = "An amazing plot"}`r ''`
plot(cars)
```

```{r mtcars, fig.cap = "Another amazing plot"}`r ''`
plot(mpg ~ hp, mtcars)
```
````

Section \@ref(cross-ref) demonstrates how this works for other elements such as tables and equations, and how to cross-reference the numbered elements within the text. Besides `html_document2`, there are several other similar functions for other output formats, such as `pdf_document2` and `word_document2`.

You can add this feature to R Markdown output formats outside **bookdown**, too. The key is to use those formats as the "base formats" of **bookdown** output formats. For example, to number and cross-reference figures in the `rticles::jss_article` format, you can use:

```yaml
output:
  bookdown::pdf_book:
    base_format: rticles::jss_article
```

Please read the help pages of the **bookdown** output format functions to see if they have the `base_format` argument (e.g., `?bookdown::html_document2`).

## Combine words into a comma-separated phrase {#combine-words}

When you want to output a character vector for humans to read (e.g., `x <- c("apple", "banana", "cherry")`), you probably do not want something like `[1] "apple" "banana" "cherry"`, which is the normal way to print a vector in R. Instead, you may want a character string "`apple, banana, and cherry`". There is a base R function `paste()` that you can use to concatenate a character vector into a single string, e.g., `paste(x, collapse = ', ')`, and the output will be `"apple, banana, cherry"`. The problems are (1) the conjunction "and" is missing, and (2) when the vector only contains two elements, we should not use commas (e.g., the output should be `"apple and banana"` instead of `"apple, banana"`).

The function `knitr::combine_words()` can be used to concatenate words into a phrase regardless of the length of the character vector. Basically, for a single word, it will just return this word; for two words A and B, it return `"A and B"`; for three or more words, it returns `"A, B, C, ..., Y, and Z"`. The function also has a few arguments that can customize the output. For example, if you want to output the words in pairs of backticks, you may use ``knitr::combine_words(x, before = '`')``.

```{r, collapse=TRUE}
v = c("apple", "banana", "cherry")
knitr::combine_words(v)
knitr::combine_words(v, before = '`', after = "'")
knitr::combine_words(v, and = "")
knitr::combine_words(v, sep = " / ", and = "")
knitr::combine_words(v[1])  # a single word
knitr::combine_words(v[1:2])  # two words
knitr::combine_words(LETTERS[1:5])
```

This function can be particularly handy when it is used in an inline R expression, e.g.,

```markdown
This morning we had `r knitr::inline_expr("knitr::combine_words(v)")` for breakfast.
```

## Preserve a large number of linebreaks {#linebreaks}

Markdown users may be surprised to realize that whitespaces (including linebreaks) are usually meaningless unless they are used in a verbatim environment (code blocks). Two or more spaces are the same as one space, and a linebreak is the same as a space. If you have used LaTeX or HTML before, you may not be surprised because the rule is the same in these languages.

In Markdown, we often use a blank line to separate elements such as paragraphs. To break a line without introducing a new paragraph, you have to use two trailing spaces. Sometimes you may want to break the lines for many times, especially when you write or quote poems or lyrics. Adding two spaces after each line manually is a tedious task. The function `blogdown:::quote_poem()` can do this task automatically, e.g.,

```{r, collapse=TRUE}
blogdown:::quote_poem(c('This line', 'should be', 'broken.'))
```

If you use the RStudio IDE, you can select the text in which you want to preserve the linebreaks, and apply the addin "Quote Poem". For example, the text below (in a fenced code block) does not contain trailing spaces:

```md
Like Barley Bending
　by Sara Teasdale

Like barley bending
　In low fields by the sea,
Singing in hard wind
　Ceaselessly;

Like barley bending
　And rising again,
So would I, unbroken,
　Rise from pain;

So would I softly,
　Day long, night long,
Change my sorrow
　Into song.
```

After we select the above poem and click the RStudio addin "Quote Poem", the output will be:

> Like Barley Bending  
　by Sara Teasdale
>
> Like barley bending  
　In low fields by the sea,  
Singing in hard wind  
　Ceaselessly;
>
> Like barley bending  
　And rising again,  
So would I, unbroken,  
　Rise from pain;
>
> So would I softly,  
　Day long, night long,  
Change my sorrow  
　Into song.

Some users may ask, "Since the fenced code block preserves whitespaces, why not putting poems in code blocks?" Code could be poetic, but poems are not code. Do not be too addicted to coding.

## Put together all code in the appendix {#code-appendix}

Unless the target readers are highly interested in the computational details while they read a report, you may not want to show the source code blocks in the report, but set the chunk option `echo = FALSE` to hide the source code instead, so readers will not be distracted by the program code for computing. However, the source code is still important for the sake of reproducible research. Sometimes readers may want to verify the computational correctness after they have finished reading the report. In this case, it can be a good idea to hold all code blocks in the body of the report, and display them at the end of a document (e.g., in an appendix).

There is a simple method of extracting all code chunks in a document and put them together in a single code chunk using the chunk option `ref.label` (label references) and the function `knitr::all_labels()`, e.g.,

````md
# Appendix: All code for this report

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}`r ''`
```
````

The chunk option `ref.label` takes a vector of chunk labels to retrieve the content of these chunks. For example, the code chunk with the label `chunk-a` is the combination of `chunk-c` and `chunk-b` below:

````md
```{r chunk-a, ref.label=c('chunk-c', 'chunk-b')}`r ''`
```

```{r chunk-b}`r ''`
# this is the chunk b
1 + 1
```

```{r chunk-c}`r ''`
# this is the chunk c
2 + 2
```
````

In other words, `chunk-a` is essentially this:

````md
```{r chunk-a}`r ''`
# this is the chunk c
2 + 2
# this is the chunk b
1 + 1
```
````

The chunk option `ref.label` has provided a very flexible way of reorganizing code chunks in a document without resorting to cut-and-paste. It does not matter if the code chunks referenced are before or after the code chunk that uses `ref.label`. An early code chunk can reference a later chunk.

The function `knitr::all_labels()` returns a vector of all chunk labels in the document, so `ref.label = knitr::all_labels()` means retrieving all source code chunks to this code chunk. With the chunk options `echo = TRUE` (display the code) and `eval = FALSE` (do not evaluate this particular code chunk because all code has been executed before), you can show a copy of all your source code in one code chunk.

Since `ref.label` can be a character vector of arbitrary chunk labels, you can certainly filter the labels to decide a subset of code chunks to display in the code appendix. Below is an example (credits to [Ariel Muldoon](https://yihui.name/en/2018/09/code-appendix/)) of excluding the labels `setup` and `get-labels`:

````md
```{r get-labels, echo = FALSE}`r ''`
labs = knitr::all_labels()
labs = setdiff(labs, c("setup", "get-labels"))
```

```{r all-code, ref.label=labs, eval=FALSE}`r ''`
```
````

You can also filter code chunks using the arguments of `knitr::all_labels()`. For example, you may use `knitr::all_labels(engine == "Rcpp", echo == FALSE)` to obtain all your code chunks that use the `Rcpp` engine (`engine == "Rcpp"`) and are not displayed in the document (`echo = FALSE`). If you want precise control over which code chunks to display in the appendix, you may use a special chunk option `appendix = TRUE` on certain code chunks, and `ref.label = knitr::all_labels(appendix == TRUE)` to obtain the labels of these code chunks.
